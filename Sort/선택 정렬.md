# 선택 정렬

+ 개기본 3정렬 형제 중 둘째로, 순차적으로 첫번째 인덱스부터 최소값 혹은 최대값을 찾아 정렬하는 방식이다. 들어갈 자리에 순차적으로 값을 선택해 넣는다고 해서 선택 정렬 또는 순차 정렬이라고 한다. 코드가 이해하기 쉽지만, 성능상 문제가 여전히 존재한다.

# 1. 코드

<pre>
    <code>
        #include <stdio.h>

        int main(void) {
            // 정렬 대상 배열
            int arr[] = {5, 3, 2, 1, 4};
            
            // 정렬 대상 배열 사이즈
            int size = sizeof(arr) / sizeof(int);
            
            // 정렬 시작
            for (int i = 0; i < size - 1; i++) {
                // 최소값 저장
                int idxMin = i;
                
                // 배열에서 최소값 찾기
                for (int j = i + 1; j < size; j++) {
                    if (arr[j] < arr[idxMin]) {
                        idxMin = j;
                    }
                }
                
                // arr[i] 와 min과 교체
                int temp = arr[i];
                
                arr[i] = arr[idxMin];
                arr[idxMin] = temp;
            }
            
            for (int i = 0; i < size; i++) {
                printf("%d\n", arr[i]);
            }
            
            return 0;
        }
    <code>
</pre>

# 2. 풀이

+ 5, 4, 3, 2, 1의 배열이 있다고 가정하자.
+ 선택 정렬은 메인 반복 횟수는 리스트 갯수 - 1개만 반복한다. 선택 정렬의 경우 맨앞의 값은 이미 정렬이 됬다고 가정하기 때문에 죄다 돌려 하나씩 비교하는 버블 정렬보다는 속도가 빠르다.
+ 이미 정렬된 앞의 값들을 제외한 나머지에서 최소 혹은 최대 값을 찾는 과정이 필요하다.
+ 선택 정렬 최초 실행 시 최소값을 가리키는 idxMin 첫번째 인덱스 값을 넣는다. 아직 정렬된 내용이 없기 때문이다. (i = 0, j = 1, idxMin = 0)
+ idxMin 값과 두번째 값을 비교한다. 두번째 값이 첫번째 값보다 작으므로 idxMin이 두번째로 업데이트된다. (i = 0, j = 1, idxMin = 1)
+ idxMin 값과 세번째 값을 비교한다. 세번째 값이 idxMin 값보다 작으므로 idxMin이 세번째로 업데이트 된다. (i = 0, j = 1, idxMin = 2)
+ idxMin 값과 네번째 값을 비교한다. 네번째 값이 idxMin 값보다 작으므로 idxMin이 네번째로 업데이트 된다. (i = 0, j = 1, idxMin = 3)
+ idxMin 값과 다섯번째 값을 비교한다. idxMin 값이 더 작으므로 최종적으로 배열에서 가장 작은 값을 가리키는 인덱스가 확정된다. (i = 0, j = 1, idxMin = 3)
+ 첫번째 인덱스와 idxMin 값이 스왑되고 i값이 1로 증가한다.
+ 가장 첫번째 값은 이미 정렬이 완료 되었으므로 다음 비교에서 제외한다. idxMin 값을 두번째 인덱스로 초기화하고 두번째와 세번째 인덱스의 값을 비교한다. (i = 1, j = 2, idxMin = 1)
+ 이 과정을 반복하면 1, 2, 3, 4, 5로 배열이 정렬된다.